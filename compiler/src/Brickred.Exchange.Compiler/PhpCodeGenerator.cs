using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;

namespace Brickred.Exchange.Compiler
{
    using EnumItemType = ProtocolDescriptor.EnumDef.ItemType;
    using EnumMapItemType = ProtocolDescriptor.EnumMapDef.ItemType;
    using FieldType = ProtocolDescriptor.StructDef.FieldType;

    public sealed class PhpCodeGenerator : BaseCodeGenerator
    {
        private ProtocolDescriptor descriptor = null;
        private string newLineStr = "";

        public PhpCodeGenerator()
        {
        }

        public override void Dispose()
        {
            this.newLineStr = "";

            if (this.descriptor != null) {
                this.descriptor = null;
            }
        }

        public override bool Generate(
            ProtocolDescriptor descriptor,
            string outputDir, NewLineType newLineType)
        {
            this.descriptor = descriptor;

            if (newLineType == NewLineType.Dos) {
                this.newLineStr = "\r\n";
            } else {
                this.newLineStr = "\n";
            }

            string filePath = Path.Combine(
                outputDir, this.descriptor.ProtoDef.Name + ".php");
            string fileContent = GenerateSourceFile();

            try {
                File.WriteAllText(filePath, fileContent);
            } catch (Exception e) {
                Console.Error.WriteLine(string.Format(
                    "error: write file {0} failed: {1}",
                    filePath, e.Message));
                return false;
            }

            return true;
        }

        private string GenerateSourceFile()
        {
            string phpTagStart;
            string phpTagEnd;
            string dontEditComment;
            string namespaceDecl;
            string useStatementsDecl;
            List<string> declList = new List<string>();

            GetDontEditComment(
                out dontEditComment);
            GetPhpTag(
                this.descriptor.ProtoDef,
                out phpTagStart, out phpTagEnd);
            GetNamespaceDecl(
                this.descriptor.ProtoDef,
                out namespaceDecl);
            GetUseStatementsDecl(
                this.descriptor.ProtoDef,
                out useStatementsDecl);

            ProtocolDescriptor.ProtocolDef protoDef =
                this.descriptor.ProtoDef;
            for (int i = 0; i < protoDef.Enums.Count; ++i) {
                string decl;
                GetEnumDecl(protoDef.Enums[i], out decl);
                declList.Add(decl);
            }
            for (int i = 0; i < protoDef.Structs.Count; ++i) {
                string decl;
                GetStructDecl(protoDef.Structs[i], out decl);
                declList.Add(decl);
            }
            for (int i = 0; i < protoDef.EnumMaps.Count; ++i) {
                string decl;
                GetEnumMapDecl(protoDef.EnumMaps[i], out decl);
                declList.Add(decl);
            }

            StringBuilder sb = new StringBuilder();
            sb.Append(phpTagStart);
            sb.Append(dontEditComment);
            sb.Append(this.newLineStr);
            if (namespaceDecl != "") {
                sb.Append(namespaceDecl);
                sb.Append(this.newLineStr);
            }
            if (useStatementsDecl != "") {
                sb.Append(useStatementsDecl);
                sb.Append(this.newLineStr);
            }
            if (declList.Count > 0) {
                sb.Append(string.Join(this.newLineStr, declList));
                sb.Append(this.newLineStr);
            }
            sb.Append(phpTagEnd);

            return sb.ToString();
        }

        private void GetPhpTag(
            ProtocolDescriptor.ProtocolDef protoDef,
            out string start, out string end)
        {
            start = string.Format(
                "<?php{0}", this.newLineStr);
            end = string.Format(
                "/* end of {0}.php */{1}",
                protoDef.Name, this.newLineStr);
        }

        private void GetDontEditComment(out string output)
        {
            output = string.Format(
                "/*{0}" +
                " * Generated by brickred exchange compiler.{0}" +
                " * Do not edit unless you are sure that you know what you are doing.{0}" +
                " */{0}",
                this.newLineStr);
        }

        private string GetEnumFullQualifiedName(
            ProtocolDescriptor.EnumDef enumDef)
        {
            ProtocolDescriptor.ProtocolDef protoDef = enumDef.ParentRef;
            ProtocolDescriptor.NamespaceDef namespaceDef = null;

            if (protoDef.Namespaces.TryGetValue(
                    "php", out namespaceDef) == false ||
                namespaceDef.NamespaceParts.Count == 0) {
                return enumDef.Name;
            } else {
                return @"\" + string.Join(@"\", namespaceDef.NamespaceParts) +
                       @"\" + enumDef.Name;
            }
        }

        private string GetStructFullQualifiedName(
            ProtocolDescriptor.StructDef structDef)
        {
            ProtocolDescriptor.ProtocolDef protoDef = structDef.ParentRef;
            ProtocolDescriptor.NamespaceDef namespaceDef = null;

            if (protoDef.Namespaces.TryGetValue(
                    "php", out namespaceDef) == false ||
                namespaceDef.NamespaceParts.Count == 0) {
                return structDef.Name;
            } else {
                return @"\" + string.Join(@"\", namespaceDef.NamespaceParts) +
                       @"\" + structDef.Name;
            }
        }

        private string GetEnumItemFullQualifiedName(
            ProtocolDescriptor.EnumDef.ItemDef itemDef)
        {
            ProtocolDescriptor.EnumDef enumDef = itemDef.ParentRef;
            ProtocolDescriptor.ProtocolDef protoDef = enumDef.ParentRef;
            ProtocolDescriptor.NamespaceDef namespaceDef = null;

            if (protoDef.Namespaces.TryGetValue(
                    "php", out namespaceDef) == false ||
                namespaceDef.NamespaceParts.Count == 0) {
                return enumDef.Name + "::" + itemDef.Name;
            } else {
                return @"\" + string.Join(@"\", namespaceDef.NamespaceParts) +
                       @"\" + enumDef.Name + "::" + itemDef.Name;
            }
        }

        private string GetPhpTypeDefaultValue(
            ProtocolDescriptor.StructDef.FieldDef fieldDef)
        {
            FieldType checkType = fieldDef.Type;

            string defaultValue = "";
            if (checkType == FieldType.I8 ||
                checkType == FieldType.U8 ||
                checkType == FieldType.I16 ||
                checkType == FieldType.U16 ||
                checkType == FieldType.I32 ||
                checkType == FieldType.U32) {
                defaultValue = "0";
            } else if (checkType == FieldType.I64) {
                defaultValue = "new Int64()";
            } else if (checkType == FieldType.U64) {
                defaultValue = "new UInt64()";
            } else if (checkType == FieldType.String ||
                       checkType == FieldType.Bytes) {
                defaultValue = "''";
            } else if (checkType == FieldType.Bool) {
                defaultValue = "false";
            } else if (checkType == FieldType.Enum) {
                if (fieldDef.RefEnumDef.Items.Count > 0) {
                    defaultValue = GetEnumItemFullQualifiedName(
                        fieldDef.RefEnumDef.Items[0]);
                } else {
                    defaultValue = "0";
                }
            } else if (checkType == FieldType.Struct) {
                defaultValue = string.Format("new {0}()",
                    GetStructFullQualifiedName(fieldDef.RefStructDef));
            } else if (checkType == FieldType.List) {
                defaultValue = "array()";
            }

            return defaultValue;
        }

        private void GetNamespaceDecl(
            ProtocolDescriptor.ProtocolDef protoDef, out string output)
        {
            output = "";

            ProtocolDescriptor.NamespaceDef namespaceDef = null;
            if (protoDef.Namespaces.TryGetValue(
                    "php", out namespaceDef) == false) {
                return;
            }
            if (namespaceDef.Namespace == "") {
                return;
            }

            output = string.Format(
                "namespace {0};{1}",
                string.Join(@"\", namespaceDef.NamespaceParts),
                this.newLineStr);
        }

        private void GetUseStatementsDecl(
            ProtocolDescriptor.ProtocolDef protoDef, out string output)
        {
            bool useBrickredExchangeCodec = false;
            bool useBrickredExchangeInt64 = false;
            bool useBrickredExchangeUInt64 = false;

            for (int i = 0; i < protoDef.Structs.Count; ++i) {
                ProtocolDescriptor.StructDef structDef =
                    protoDef.Structs[i];

                for (int j = 0; j < structDef.Fields.Count; ++j) {
                    ProtocolDescriptor.StructDef.FieldDef fieldDef =
                        structDef.Fields[j];

                    if (fieldDef.Type == FieldType.I64) {
                        useBrickredExchangeInt64 = true;
                    } else if (fieldDef.Type == FieldType.U64) {
                        useBrickredExchangeUInt64 = true;
                    }

                    useBrickredExchangeCodec = true;
                }
            }

            StringBuilder sb = new StringBuilder();

            if (useBrickredExchangeCodec) {
                sb.AppendFormat(
                    @"use \Brickred\Exchange\Codec;{0}",
                    this.newLineStr);
            }
            if (useBrickredExchangeInt64) {
                sb.AppendFormat(
                    @"use \Brickred\Exchange\Int64;{0}",
                    this.newLineStr);
            }
            if (useBrickredExchangeUInt64) {
                sb.AppendFormat(
                    @"use \Brickred\Exchange\UInt64;{0}",
                    this.newLineStr);
            }

            output = sb.ToString();
        }

        private void GetEnumDecl(
            ProtocolDescriptor.EnumDef enumDef, out string output)
        {
            StringBuilder sb = new StringBuilder();

            string start = string.Format(
                "final class {0}{1}" +
                "{{{1}",
                enumDef.Name, this.newLineStr);
            string end = string.Format(
                "}}{0}", this.newLineStr);
            string indent = "    ";

            sb.Append(start);

            for (int i = 0; i < enumDef.Items.Count; ++i) {
                ProtocolDescriptor.EnumDef.ItemDef itemDef =
                    enumDef.Items[i];

                if (itemDef.Type == EnumItemType.Default ||
                    itemDef.Type == EnumItemType.Int) {
                    sb.AppendFormat("{0}const {1} = {2};{3}",
                        indent, itemDef.Name,
                        itemDef.IntValue, this.newLineStr);
                } else if (itemDef.Type == EnumItemType.CurrentEnumRef) {
                    sb.AppendFormat("{0}const {1} = self::{2};{3}",
                        indent, itemDef.Name,
                        itemDef.RefEnumItemDef.Name, this.newLineStr);
                } else if (itemDef.Type == EnumItemType.OtherEnumRef) {
                    sb.AppendFormat("{0}const {1} = {2};{3}",
                        indent, itemDef.Name,
                        GetEnumItemFullQualifiedName(itemDef.RefEnumItemDef),
                        this.newLineStr);
                }
            }

            sb.Append(end);

            output = sb.ToString();
        }

        private void GetStructDecl(
            ProtocolDescriptor.StructDef structDef, out string output)
        {
            StringBuilder sb = new StringBuilder();

            string start = string.Format(
                "final class {0}{1}" +
                "{{{1}",
                structDef.Name, this.newLineStr);
            string end = string.Format(
                "}}{0}", this.newLineStr);
            string fieldDecl;
            string constructorDecl;
            string encodeFuncDecl;
            string decodeFuncDecl;
            string toArrayFuncDecl;
            string fromArrayFuncDecl;
            string jsonFuncDecl;
            string optionalFuncDecl;

            GetStructDeclFieldDecl(
                structDef, out fieldDecl);
            GetStructDeclConstructor(
                structDef, out constructorDecl);
            GetStructDeclEncodeFunc(
                structDef, out encodeFuncDecl);
            GetStructDeclDecodeFunc(
                structDef, out decodeFuncDecl);
            GetStructDeclToArrayFunc(
                structDef, out toArrayFuncDecl);
            GetStructDeclFromArrayFunc(
                structDef, out fromArrayFuncDecl);
            GetStructDeclJsonFunc(
                structDef, out jsonFuncDecl);
            GetStructDeclOptionalFunc(
                structDef, out optionalFuncDecl);

            sb.Append(start);
            if (fieldDecl != "") {
                sb.Append(fieldDecl);
                sb.Append(this.newLineStr);
            }
            sb.Append(constructorDecl);
            sb.Append(this.newLineStr);
            sb.Append(encodeFuncDecl);
            sb.Append(this.newLineStr);
            sb.Append(decodeFuncDecl);
            sb.Append(this.newLineStr);
            sb.Append(toArrayFuncDecl);
            sb.Append(this.newLineStr);
            sb.Append(fromArrayFuncDecl);
            sb.Append(this.newLineStr);
            sb.Append(jsonFuncDecl);
            if (optionalFuncDecl != "") {
                sb.Append(this.newLineStr);
                sb.Append(optionalFuncDecl);
            }
            sb.Append(end);

            output = sb.ToString();
        }

        private void GetStructDeclFieldDecl(
            ProtocolDescriptor.StructDef structDef, out string output)
        {
            StringBuilder sb = new StringBuilder();
            string indent = "    ";

            if (structDef.OptionalByteCount > 0) {
                sb.AppendFormat(
                    "{0}private $_has_bits_;{1}",
                    indent, this.newLineStr);
            }

            for (int i = 0; i < structDef.Fields.Count; ++i) {
                ProtocolDescriptor.StructDef.FieldDef fieldDef =
                    structDef.Fields[i];
                sb.AppendFormat("{0}public ${1};{2}",
                    indent, fieldDef.Name, this.newLineStr);
            }

            output = sb.ToString();
        }

        private void GetStructDeclConstructor(
            ProtocolDescriptor.StructDef structDef, out string output)
        {
            StringBuilder sb = new StringBuilder();
            string indent = "    ";

            string start = string.Format(
                "{0}public function __construct(){1}" +
                "{0}{{{1}",
                indent, this.newLineStr);
            string end = string.Format(
                "{0}}}{1}",
                indent, this.newLineStr);

            sb.Append(start);

            indent += "    ";

            if (structDef.OptionalByteCount > 0) {
                sb.AppendFormat(
                    "{0}$this->_has_bits_ = array({1});{2}",
                    indent,
                    string.Join(", ", new int[structDef.OptionalByteCount]),
                    this.newLineStr);
            }

            for (int i = 0; i < structDef.Fields.Count; ++i) {
                ProtocolDescriptor.StructDef.FieldDef fieldDef =
                    structDef.Fields[i];

                string defaultValue = GetPhpTypeDefaultValue(fieldDef);
                sb.AppendFormat("{0}$this->{1} = {2};{3}",
                    indent, fieldDef.Name, defaultValue, this.newLineStr);
            }

            sb.Append(end);

            output = sb.ToString();
        }

        private void GetStructDeclEncodeFunc(
            ProtocolDescriptor.StructDef structDef, out string output)
        {
            StringBuilder sb = new StringBuilder();
            string indent = "    ";

            string start = string.Format(
                "{0}public function encode(){1}" +
                "{0}{{{1}",
                indent, this.newLineStr);
            string end = string.Format(
                "{0}}}{1}",
                indent, this.newLineStr);

            sb.Append(start);

            indent += "    ";

            if (structDef.Fields.Count == 0) {
                sb.AppendFormat(
                    "{0}return '';{1}",
                    indent, this.newLineStr);
            } else {
                sb.AppendFormat(
                    "{0}$output = '';{1}" +
                    "{1}",
                    indent, this.newLineStr);

                if (structDef.OptionalByteCount > 0) {
                    sb.AppendFormat(
                        "{0}for ($i = 0; $i < {1}; ++$i) {{{2}" +
                        "{0}    $output .= Codec::writeInt8(" +
                        "$this->_has_bits_[$i]);{2}" +
                        "{0}}}{2}" +
                        "{2}",
                        indent, structDef.OptionalByteCount,
                        this.newLineStr);
                }

                for (int i = 0; i < structDef.Fields.Count; ++i) {
                    string writeStatement;
                    GetStructDeclEncodeFuncWriteStatement(
                        structDef.Fields[i], out writeStatement);
                    sb.Append(writeStatement);
                }

                sb.AppendFormat(
                    "{1}" +
                    "{0}return $output;{1}",
                    indent, this.newLineStr);
            }

            sb.Append(end);

            output = sb.ToString();
        }

        private void GetStructDeclEncodeFuncWriteStatement(
            ProtocolDescriptor.StructDef.FieldDef fieldDef, out string output)
        {
            StringBuilder sb = new StringBuilder();

            string indent = "        ";
            string optionalCheckStart = "";
            string optionalCheckEnd = "";

            if (fieldDef.IsOptional) {
                optionalCheckStart = string.Format(
                    "{0}if ($this->has_{1}()) {{{2}",
                    indent, fieldDef.Name, this.newLineStr);
                optionalCheckEnd = string.Format(
                    "{0}}}{1}",
                    indent, this.newLineStr);
                indent += "    ";
            }

            sb.Append(optionalCheckStart);

            FieldType checkType;
            if (fieldDef.Type == FieldType.List) {
                checkType = fieldDef.ListType;
            } else {
                checkType = fieldDef.Type;
            }
            bool isList = (fieldDef.Type == FieldType.List);

            if (checkType == FieldType.I8 ||
                checkType == FieldType.U8 ||
                checkType == FieldType.Bool) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}$output .= Codec::writeList(" +
                        "$this->{1}, 'writeInt8');{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}$output .= Codec::writeInt8($this->{1});{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.I16 ||
                       checkType == FieldType.U16) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}$output .= Codec::writeList(" +
                        "$this->{1}, 'writeInt16');{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}$output .= Codec::writeInt16($this->{1});{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.I32 ||
                       checkType == FieldType.U32 ||
                       checkType == FieldType.Enum) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}$output .= Codec::writeList(" +
                        "$this->{1}, 'writeInt32');{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}$output .= Codec::writeInt32($this->{1});{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.I64 ||
                       checkType == FieldType.U64) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}$output .= Codec::writeList(" +
                        "$this->{1}, 'writeInt64');{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}$output .= Codec::writeInt64($this->{1});{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.String ||
                       checkType == FieldType.Bytes) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}$output .= Codec::writeList(" +
                        "$this->{1}, 'writeString');{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}$output .= Codec::writeString($this->{1});{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.Struct) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}$output .= Codec::writeList(" +
                        "$this->{1}, 'writeStruct');{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}$output .= Codec::writeStruct($this->{1});{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            }

            sb.Append(optionalCheckEnd);

            output = sb.ToString();
        }

        private void GetStructDeclDecodeFunc(
            ProtocolDescriptor.StructDef structDef, out string output)
        {
            StringBuilder sb = new StringBuilder();
            string indent = "    ";

            string start = string.Format(
                "{0}public function decodeFromStream($s){1}" +
                "{0}{{{1}",
                indent, this.newLineStr);
            string end = string.Format(
                "{0}}}{1}" +
                "{1}" +
                "{0}public function decode($buf){1}" +
                "{0}{{{1}" +
                "{0}    $s = Codec::openStreamForBuffer($buf);{1}" +
                "{0}    $this->decodeFromStream($s);{1}" +
                "{0}    fclose($s);{1}" +
                "{0}}}{1}",
                indent, this.newLineStr);

            sb.Append(start);

            indent += "    ";

            if (structDef.OptionalByteCount > 0) {
                sb.AppendFormat(
                    "{0}for ($i = 0; $i < {1}; ++$i) {{{2}" +
                    "{0}    $this->_has_bits_[$i] = Codec::readUint8($s);{2}" +
                    "{0}}}{2}" +
                    "{2}",
                    indent, structDef.OptionalByteCount,
                    this.newLineStr);
            }

            for (int i = 0; i < structDef.Fields.Count; ++i) {
                string readStatement;
                GetStructDeclDecodeFuncReadStatement(
                    structDef.Fields[i], out readStatement);
                sb.Append(readStatement);
            }

            sb.Append(end);

            output = sb.ToString();
        }

        private void GetStructDeclDecodeFuncReadStatement(
            ProtocolDescriptor.StructDef.FieldDef fieldDef, out string output)
        {
            StringBuilder sb = new StringBuilder();

            string indent = "        ";
            string optionalCheckStart = "";
            string optionalCheckEnd = "";

            if (fieldDef.IsOptional) {
                optionalCheckStart = string.Format(
                    "{0}if ($this->has_{1}()) {{{2}",
                    indent, fieldDef.Name, this.newLineStr);
                optionalCheckEnd = string.Format(
                    "{0}}}{1}",
                    indent, this.newLineStr);
                indent += "    ";
            }

            sb.Append(optionalCheckStart);

            FieldType checkType;
            if (fieldDef.Type == FieldType.List) {
                checkType = fieldDef.ListType;
            } else {
                checkType = fieldDef.Type;
            }
            bool isList = (fieldDef.Type == FieldType.List);

            if (checkType == FieldType.I8) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readList($s, 'readInt8');{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readInt8($s);{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.U8) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readList($s, 'readUInt8');{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readUInt8($s);{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.I16) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readList($s, 'readInt16');{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readInt16($s);{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.U16) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readList($s, 'readUInt16');{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readUInt16($s);{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.I32 ||
                       checkType == FieldType.Enum) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readList($s, 'readInt32');{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readInt32($s);{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.U32) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readList($s, 'readUInt32');{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readUInt32($s);{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.I64) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readList($s, 'readInt64');{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readInt64($s);{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.U64) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readList($s, 'readUInt64');{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readUInt64($s);{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.String ||
                       checkType == FieldType.Bytes) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readList($s, 'readString');{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readString($s);{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.Bool) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readList($s, 'readBool');{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readBool($s);{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.Struct) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readStructList($s, '{2}');{3}",
                        indent, fieldDef.Name,
                        GetStructFullQualifiedName(fieldDef.RefStructDef),
                        this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readStruct($s, '{2}');{3}",
                        indent, fieldDef.Name,
                        GetStructFullQualifiedName(fieldDef.RefStructDef),
                        this.newLineStr);
                }
            }

            sb.Append(optionalCheckEnd);

            output = sb.ToString();
        }

        private void GetStructDeclToArrayFunc(
            ProtocolDescriptor.StructDef structDef, out string output)
        {
            StringBuilder sb = new StringBuilder();
            string indent = "    ";

            string start = string.Format(
                "{0}public function toArray(){1}" +
                "{0}{{{1}",
                indent, this.newLineStr);
            string end = string.Format(
                "{0}}}{1}",
                indent, this.newLineStr);

            sb.Append(start);

            indent += "    ";

            if (structDef.Fields.Count == 0) {
                sb.AppendFormat(
                    "{0}return array();{1}",
                    indent, this.newLineStr);
            } else {
                sb.AppendFormat(
                    "{0}$output = array();{1}" +
                    "{1}",
                    indent, this.newLineStr);

                for (int i = 0; i < structDef.Fields.Count; ++i) {
                    string writeStatement;
                    GetStructDeclToArrayFuncWriteStatement(
                        structDef.Fields[i], out writeStatement);
                    sb.Append(writeStatement);
                }

                sb.AppendFormat(
                    "{1}" +
                    "{0}return $output;{1}",
                    indent, this.newLineStr);
            }

            sb.Append(end);

            output = sb.ToString();
        }

        private void GetStructDeclToArrayFuncWriteStatement(
            ProtocolDescriptor.StructDef.FieldDef fieldDef, out string output)
        {
            StringBuilder sb = new StringBuilder();

            string indent = "        ";
            string optionalCheckStart = "";
            string optionalCheckEnd = "";

            if (fieldDef.IsOptional) {
                optionalCheckStart = string.Format(
                    "{0}if ($this->has_{1}()) {{{2}",
                    indent, fieldDef.Name, this.newLineStr);
                optionalCheckEnd = string.Format(
                    "{0}}}{1}",
                    indent, this.newLineStr);
                indent += "    ";
            }

            sb.Append(optionalCheckStart);

            FieldType checkType;
            if (fieldDef.Type == FieldType.List) {
                checkType = fieldDef.ListType;
            } else {
                checkType = fieldDef.Type;
            }
            bool isList = (fieldDef.Type == FieldType.List);

            if (checkType == FieldType.I8 ||
                checkType == FieldType.U8 ||
                checkType == FieldType.I16 ||
                checkType == FieldType.U16 ||
                checkType == FieldType.I32 ||
                checkType == FieldType.U32 ||
                checkType == FieldType.String ||
                checkType == FieldType.Bytes ||
                checkType == FieldType.Bool ||
                checkType == FieldType.Enum) {
                sb.AppendFormat(
                    "{0}$output['{1}'] = $this->{1};{2}",
                    indent, fieldDef.Name, this.newLineStr);
            } else if (checkType == FieldType.I64 ||
                       checkType == FieldType.U64) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}$output['{1}'] = array();{2}" +
                        "{0}for ($i = 0; $i < count($this->{1}); ++$i) {{{2}" +
                        "{0}    $output['{1}'][$i] = $this->{1}[$i]->toString();{2}" +
                        "{0}}}{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}$output['{1}'] = $this->{1}->toString();{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.Struct) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}$output['{1}'] = array();{2}" +
                        "{0}for ($i = 0; $i < count($this->{1}); ++$i) {{{2}" +
                        "{0}    $output['{1}'][$i] = $this->{1}[$i]->toArray();{2}" +
                        "{0}}}{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}$output['{1}'] = $this->{1}->toArray();{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            }

            sb.Append(optionalCheckEnd);

            output = sb.ToString();
        }

        private void GetStructDeclFromArrayFunc(
            ProtocolDescriptor.StructDef structDef, out string output)
        {
            StringBuilder sb = new StringBuilder();
            string indent = "    ";

            string start = string.Format(
                "{0}public function fromArray($array){1}" +
                "{0}{{{1}",
                indent, this.newLineStr);
            string end = string.Format(
                "{0}}}{1}",
                indent, this.newLineStr);

            sb.Append(start);

            indent += "    ";

            if (structDef.OptionalByteCount > 0) {
                sb.AppendFormat(
                    "{0}for ($i = 0; $i < {1}; ++$i) {{{2}" +
                    "{0}    $this->_has_bits_[$i] = 0;{2}" +
                    "{0}}}{2}" +
                    "{2}",
                    indent, structDef.OptionalByteCount,
                    this.newLineStr);
            }

            for (int i = 0; i < structDef.Fields.Count; ++i) {
                string readStatement;
                GetStructDeclFromArrayFuncReadStatement(
                    structDef.Fields[i], out readStatement);
                sb.Append(readStatement);
            }

            sb.Append(end);

            output = sb.ToString();
        }

        private void GetStructDeclFromArrayFuncReadStatement(
            ProtocolDescriptor.StructDef.FieldDef fieldDef, out string output)
        {
            StringBuilder sb = new StringBuilder();

            string indent = "        ";
            string optionalCheckStart = "";
            string optionalCheckEnd = "";

            if (fieldDef.IsOptional) {
                optionalCheckStart = string.Format(
                    "{0}if (isset($array['{1}'])) {{{2}" +
                    "{0}    $this->set_has_{1}();{2}",
                    indent, fieldDef.Name, this.newLineStr);
                optionalCheckEnd = string.Format(
                    "{0}}}{1}",
                    indent, this.newLineStr);
                indent += "    ";
            }

            sb.Append(optionalCheckStart);

            FieldType checkType;
            if (fieldDef.Type == FieldType.List) {
                checkType = fieldDef.ListType;
            } else {
                checkType = fieldDef.Type;
            }
            bool isList = (fieldDef.Type == FieldType.List);

            if (checkType == FieldType.I8 ||
                checkType == FieldType.U8 ||
                checkType == FieldType.I16 ||
                checkType == FieldType.U16 ||
                checkType == FieldType.I32 ||
                checkType == FieldType.U32 ||
                checkType == FieldType.Enum) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readListFromArray(" +
                        "$array, '{1}', 'readIntFromArray');{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readIntFromArray(" +
                        "$array, '{1}');{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.I64) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readListFromArray(" +
                        "$array, '{1}', 'readInt64FromArray');{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readInt64FromArray(" +
                        "$array, '{1}');{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.U64) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readListFromArray(" +
                        "$array, '{1}', 'readUInt64FromArray');{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readUInt64FromArray(" +
                        "$array, '{1}');{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.String ||
                       checkType == FieldType.Bytes) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readListFromArray(" +
                        "$array, '{1}', 'readStringFromArray');{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readStringFromArray(" +
                        "$array, '{1}');{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.Bool) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readListFromArray(" +
                        "$array, '{1}', 'readBoolFromArray');{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readBoolFromArray(" +
                        "$array, '{1}');{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.Struct) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readStructListFromArray(" +
                        "$array, '{1}', '{2}');{3}",
                        indent, fieldDef.Name,
                        GetStructFullQualifiedName(fieldDef.RefStructDef),
                        this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}$this->{1} = Codec::readStructFromArray(" +
                        "$array, '{1}', '{2}');{3}",
                        indent, fieldDef.Name,
                        GetStructFullQualifiedName(fieldDef.RefStructDef),
                        this.newLineStr);
                }
            }

            sb.Append(optionalCheckEnd);

            output = sb.ToString();
        }

        private void GetStructDeclJsonFunc(
            ProtocolDescriptor.StructDef structDef, out string output)
        {
            string indent = "    ";

            output = string.Format(
                "{0}public function toJson(){1}" +
                "{0}{{{1}" +
                "{0}    return json_encode($this->toArray());{1}" +
                "{0}}}{1}" +
                "{1}" +
                "{0}public function fromJson($json){1}" +
                "{0}{{{1}" +
                "{0}    $this->fromArray(json_decode($json, true));{1}" +
                "{0}}}{1}",
                indent, this.newLineStr);
        }

        private void GetStructDeclOptionalFunc(
            ProtocolDescriptor.StructDef structDef, out string output)
        {
            List<string> decls = new List<string>();
            string indent = "    ";

            for (int i = 0; i < structDef.Fields.Count; ++i) {
                ProtocolDescriptor.StructDef.FieldDef fieldDef =
                    structDef.Fields[i];

                if (fieldDef.IsOptional == false) {
                    continue;
                }

                string mask = string.Format("0x{0:x2}",
                    1 << fieldDef.OptionalFieldIndex % 8);

                decls.Add(string.Format(
                    "{0}public function has_{1}(){2}" +
                    "{0}{{{2}" +
                    "{0}    return (bool)($this->_has_bits_[{3}] & {4});{2}" +
                    "{0}}}{2}" +
                    "{2}" +
                    "{0}public function set_has_{1}(){2}" +
                    "{0}{{{2}" +
                    "{0}    $this->_has_bits_[{3}] |= {4};{2}" +
                    "{0}}}{2}" +
                    "{2}" +
                    "{0}public function clear_has_{1}(){2}" +
                    "{0}{{{2}" +
                    "{0}    $this->_has_bits_[{3}] &= ~{4};{2}" +
                    "{0}}}{2}" +
                    "{2}" +
                    "{0}public function set_{1}($value){2}" +
                    "{0}{{{2}" +
                    "{0}    $this->set_has_{1}();{2}" +
                    "{0}    $this->{1} = $value;{2}" +
                    "{0}}}{2}",
                    indent, fieldDef.Name, this.newLineStr,
                    fieldDef.OptionalFieldIndex / 8, mask));
            }

            output = string.Join(this.newLineStr, decls);
        }

        private void GetEnumMapDecl(
            ProtocolDescriptor.EnumMapDef enumMapDef, out string output)
        {
            StringBuilder sbEnumConst = new StringBuilder();
            StringBuilder sbNameIdMap = new StringBuilder();
            StringBuilder sbIdNameMap = new StringBuilder();

            for (int i = 0; i < enumMapDef.Items.Count; ++i) {
                ProtocolDescriptor.EnumMapDef.ItemDef itemDef =
                    enumMapDef.Items[i];

                sbEnumConst.AppendFormat(
                    "    const {0} = ", itemDef.Name);

                if (itemDef.Type == EnumMapItemType.Default ||
                    itemDef.Type == EnumMapItemType.Int) {
                    sbEnumConst.AppendFormat("{0};{1}",
                        itemDef.IntValue, this.newLineStr);
                } else if (itemDef.Type == EnumMapItemType.CurrentEnumRef) {
                    sbEnumConst.AppendFormat("self::{0};{1}",
                        itemDef.RefEnumItemDef.Name, this.newLineStr);
                }

                if (itemDef.RefStructDef == null) {
                    continue;
                }

                string qualifiedName = GetStructFullQualifiedName(
                    itemDef.RefStructDef);
                qualifiedName = Regex.Replace(
                    qualifiedName, @"^\\", "");
                qualifiedName = Regex.Replace(
                    qualifiedName, @"\\", @"\\");

                sbNameIdMap.AppendFormat(
                    "        '{0}' => {1},{2}",
                    qualifiedName, itemDef.IntValue, this.newLineStr);
                sbIdNameMap.AppendFormat(
                    "        {0} => '{1}',{2}",
                    itemDef.IntValue, qualifiedName, this.newLineStr);
            }

            if (sbEnumConst.Length > 0) {
                sbEnumConst.AppendFormat(this.newLineStr);
            }

            output = string.Format(
                "final class {0}{1}" +
                "{{{1}" +
                "{2}" +
                "    private static $s_name_id_map_ = array({1}" +
                "{3}" +
                "    );{1}" +
                "{1}" +
                "    private static $s_id_name_map_ = array({1}" +
                "{4}" +
                "    );{1}" +
                "{1}" +
                "    public static function getIdByName($name){1}" +
                "    {{{1}" +
                "        if (isset(self::$s_name_id_map_[$name])) {{{1}" +
                "            return self::$s_name_id_map_[$name];{1}" +
                "        }} else {{{1}" +
                "            return false;{1}" +
                "        }}{1}" +
                "    }}{1}" +
                "{1}" +
                "    public static function getNameById($id){1}" +
                "    {{{1}" +
                "        if (isset(self::$s_id_name_map_[$id])) {{{1}" +
                "            return self::$s_id_name_map_[$id];{1}" +
                "        }} else {{{1}" +
                "            return false;{1}" +
                "        }}{1}" +
                "    }}{1}" +
                "{1}" +
                "    public static function id($obj){1}" +
                "    {{{1}" +
                "        $name = get_class($obj);{1}" +
                "        return self::getIdByName($name);{1}" +
                "    }}{1}" +
                "{1}" +
                "    public static function create($id){1}" +
                "    {{{1}" +
                "        $name = self::getNameById($id);{1}" +
                "        if ($name === false) {{{1}" +
                "            return null;{1}" +
                "        }}{1}" +
                "{1}" +
                "        return new $name();{1}" +
                "    }}{1}" +
                "}}{1}",
                enumMapDef.Name, this.newLineStr, sbEnumConst.ToString(),
                sbNameIdMap.ToString(), sbIdNameMap.ToString());
        }
    }
}
