using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;

namespace Brickred.Exchange.Compiler
{
    using EnumItemType = ProtocolDescriptor.EnumDef.ItemType;
    using EnumMapItemType = ProtocolDescriptor.EnumMapDef.ItemType;
    using FieldType = ProtocolDescriptor.StructDef.FieldType;

    public sealed class CSharpCodeGenerator : BaseCodeGenerator
    {
        private ProtocolDescriptor descriptor = null;
        private string newLineStr = "";

        public CSharpCodeGenerator()
        {
        }

        public override void Dispose()
        {
            this.newLineStr = "";

            if (this.descriptor != null) {
                this.descriptor = null;
            }
        }

        public override bool Generate(
            ProtocolDescriptor descriptor,
            string outputDir, NewLineType newLineType)
        {
            this.descriptor = descriptor;

            if (newLineType == NewLineType.Dos) {
                this.newLineStr = "\r\n";
            } else {
                this.newLineStr = "\n";
            }

            string filePath = Path.Combine(
                outputDir, this.descriptor.ProtoDef.Name + ".cs");
            string fileContent = GenerateSourceFile();
            try {
                File.WriteAllText(filePath, fileContent);
            } catch (Exception e) {
                Console.Error.WriteLine(string.Format(
                    "error: write file {0} failed: {1}",
                    filePath, e.Message));
                return false;
            }

            return true;
        }

        private string GenerateSourceFile()
        {
            string dontEditComment;
            string usingStatementsDecl;
            string namespaceDeclStart;
            string namespaceDeclEnd;
            string indent = "";
            List<string> declList = new List<string>();

            GetDontEditComment(
                out dontEditComment);
            GetUsingStatementsDecl(
                this.descriptor.ProtoDef,
                out usingStatementsDecl);
            GetNamespaceDecl(
                this.descriptor.ProtoDef,
                out namespaceDeclStart, out namespaceDeclEnd);

            if (namespaceDeclStart != "") {
                indent += "    ";
            }

            ProtocolDescriptor.ProtocolDef protoDef =
                this.descriptor.ProtoDef;
            for (int i = 0; i < protoDef.Enums.Count; ++i) {
                string decl;
                GetEnumDecl(protoDef.Enums[i], indent, out decl);
                declList.Add(decl);
            }
            for (int i = 0; i < protoDef.Structs.Count; ++i) {
                string decl;
                GetStructDecl(protoDef.Structs[i], indent, out decl);
                declList.Add(decl);
            }
            for (int i = 0; i < protoDef.EnumMaps.Count; ++i) {
                string decl;
                GetEnumMapDecl(protoDef.EnumMaps[i], indent, out decl);
                declList.Add(decl);
            }

            StringBuilder sb = new StringBuilder();
            sb.Append(dontEditComment);
            sb.Append(this.newLineStr);
            sb.Append(usingStatementsDecl);
            sb.Append(this.newLineStr);
            sb.Append(namespaceDeclStart);
            sb.Append(string.Join(this.newLineStr, declList));
            sb.Append(namespaceDeclEnd);

            return sb.ToString();
        }

        private void GetDontEditComment(out string output)
        {
            output = string.Format(
                "/*{0}" +
                " * Generated by brickred exchange compiler.{0}" +
                " * Do not edit unless you are sure that you know what you are doing.{0}" +
                " */{0}",
                this.newLineStr);
        }

        private string GetEnumFullQualifiedName(
            ProtocolDescriptor.EnumDef enumDef)
        {
            ProtocolDescriptor.ProtocolDef protoDef = enumDef.ParentRef;
            ProtocolDescriptor.NamespaceDef namespaceDef = null;

            if (protoDef.Namespaces.TryGetValue(
                    "csharp", out namespaceDef) == false) {
                return enumDef.Name;
            } else {
                return string.Join(".", namespaceDef.NamespaceParts) +
                       "." + enumDef.Name;
            }
        }

        private string GetStructFullQualifiedName(
            ProtocolDescriptor.StructDef structDef)
        {
            ProtocolDescriptor.ProtocolDef protoDef = structDef.ParentRef;
            ProtocolDescriptor.NamespaceDef namespaceDef = null;

            if (protoDef.Namespaces.TryGetValue(
                    "csharp", out namespaceDef) == false) {
                return structDef.Name;
            } else {
                return string.Join(".", namespaceDef.NamespaceParts) +
                       "." + structDef.Name;
            }
        }

        private string GetEnumItemFullQualifiedName(
            ProtocolDescriptor.EnumDef.ItemDef itemDef)
        {
            ProtocolDescriptor.EnumDef enumDef = itemDef.ParentRef;
            ProtocolDescriptor.ProtocolDef protoDef = enumDef.ParentRef;
            ProtocolDescriptor.NamespaceDef namespaceDef = null;

            if (protoDef.Namespaces.TryGetValue(
                    "csharp", out namespaceDef) == false) {
                return enumDef.Name + "." + itemDef.Name;
            } else {
                return string.Join(".", namespaceDef.NamespaceParts) +
                       "." + enumDef.Name + "." + itemDef.Name;
            }
        }

        private string GetCSharpType(
            ProtocolDescriptor.StructDef.FieldDef fieldDef)
        {
            FieldType checkType;
            if (fieldDef.Type == FieldType.List) {
                checkType = fieldDef.ListType;
            } else {
                checkType = fieldDef.Type;
            }

            string csharpType = "";
            if (checkType == FieldType.I8) {
                csharpType = "sbyte";
            } else if (checkType == FieldType.U8) {
                csharpType = "byte";
            } else if (checkType == FieldType.I16) {
                csharpType = "short";
            } else if (checkType == FieldType.U16) {
                csharpType = "ushort";
            } else if (checkType == FieldType.I32) {
                csharpType = "int";
            } else if (checkType == FieldType.U32) {
                csharpType = "uint";
            } else if (checkType == FieldType.I64) {
                csharpType = "long";
            } else if (checkType == FieldType.U64) {
                csharpType = "ulong";
            } else if (checkType == FieldType.String) {
                csharpType = "string";
            } else if (checkType == FieldType.Bytes) {
                csharpType = "byte[]";
            } else if (checkType == FieldType.Bool) {
                csharpType = "bool";
            } else if (checkType == FieldType.Enum) {
                csharpType = GetEnumFullQualifiedName(
                    fieldDef.RefEnumDef);
            } else if (checkType == FieldType.Struct) {
                csharpType = GetStructFullQualifiedName(
                    fieldDef.RefStructDef);
            }

            if (fieldDef.Type == FieldType.List) {
                return string.Format("List<{0}>", csharpType);
            } else {
                return csharpType;
            }
        }

        private string GetCSharpTypeDefaultValue(
            ProtocolDescriptor.StructDef.FieldDef fieldDef)
        {
            FieldType checkType = fieldDef.Type;

            string defaultValue = "";
            if (checkType == FieldType.I8 ||
                checkType == FieldType.U8 ||
                checkType == FieldType.I16 ||
                checkType == FieldType.U16 ||
                checkType == FieldType.I32 ||
                checkType == FieldType.U32 ||
                checkType == FieldType.I64 ||
                checkType == FieldType.U64) {
                defaultValue = "0";
            } else if (checkType == FieldType.String) {
                defaultValue = "\"\"";
            } else if (checkType == FieldType.Bytes) {
                defaultValue = "new byte[0]";
            } else if (checkType == FieldType.Bool) {
                defaultValue = "false";
            } else if (checkType == FieldType.Enum) {
                if (fieldDef.RefEnumDef.Items.Count > 0) {
                    defaultValue = GetEnumItemFullQualifiedName(
                        fieldDef.RefEnumDef.Items[0]);
                } else {
                    defaultValue = string.Format("({0})0",
                        GetEnumFullQualifiedName(fieldDef.RefEnumDef));
                }
            } else if (checkType == FieldType.Struct) {
                defaultValue = string.Format("new {0}()",
                    GetStructFullQualifiedName(fieldDef.RefStructDef));
            } else if (checkType == FieldType.List) {
                defaultValue = string.Format("new {0}()",
                    GetCSharpType(fieldDef));
            }

            return defaultValue;
        }

        private void GetUsingStatementsDecl(
            ProtocolDescriptor.ProtocolDef protoDef, out string output)
        {
            bool useSystem = false;
            bool useSystemCollectionsGeneric = false;
            bool useBrickredExchange = false;

            {
                if (protoDef.Structs.Count > 0 ||
                    protoDef.EnumMaps.Count > 0) {
                    useBrickredExchange = true;
                }
                if (protoDef.EnumMaps.Count > 0) {
                    useSystem = true;
                }

                for (int i = 0; i < protoDef.Structs.Count; ++i) {
                    ProtocolDescriptor.StructDef structDef =
                        protoDef.Structs[i];

                    for (int j = 0; j < structDef.Fields.Count; ++j) {
                        ProtocolDescriptor.StructDef.FieldDef fieldDef =
                            structDef.Fields[j];

                        if (fieldDef.Type == FieldType.List) {
                            useSystemCollectionsGeneric = true;
                        }
                    }
                }
            }

            StringBuilder sb = new StringBuilder();

            if (useBrickredExchange) {
                sb.AppendFormat(
                    "using Brickred.Exchange;{0}", this.newLineStr);
            }
            if (useSystem) {
                sb.AppendFormat(
                    "using System;{0}", this.newLineStr);
            }
            if (useSystemCollectionsGeneric) {
                sb.AppendFormat(
                    "using System.Collections.Generic;{0}", this.newLineStr);
            }

            output = sb.ToString();
        }

        private void GetNamespaceDecl(
            ProtocolDescriptor.ProtocolDef protoDef,
            out string start, out string end)
        {
            start = "";
            end = "";

            ProtocolDescriptor.NamespaceDef namespaceDef = null;
            if (protoDef.Namespaces.TryGetValue(
                    "csharp", out namespaceDef) == false) {
                return;
            }
            if (namespaceDef.Namespace == "") {
                return;
            }

            start = string.Format(
                "namespace {0}{1}" +
                "{{{1}",
                namespaceDef.Namespace, this.newLineStr);
            end = string.Format(
                "}}{0}", this.newLineStr);
        }

        private void GetEnumDecl(
            ProtocolDescriptor.EnumDef enumDef,
            string indent, out string output)
        {
            StringBuilder sb = new StringBuilder();

            string start = string.Format(
                "{0}public enum {1}{2}" +
                "{0}{{{2}",
                indent, enumDef.Name, this.newLineStr);
            string end = string.Format(
                "{0}}}{1}",
                indent, this.newLineStr);

            sb.Append(start);

            indent += "    ";
            for (int i = 0; i < enumDef.Items.Count; ++i) {
                ProtocolDescriptor.EnumDef.ItemDef itemDef =
                    enumDef.Items[i];

                if (itemDef.Type == EnumItemType.Default) {
                    sb.AppendFormat("{0}{1},{2}",
                        indent, itemDef.Name, this.newLineStr);
                } else if (itemDef.Type == EnumItemType.Int) {
                    sb.AppendFormat("{0}{1} = {2},{3}",
                        indent, itemDef.Name,
                        itemDef.IntValue, this.newLineStr);
                } else if (itemDef.Type == EnumItemType.CurrentEnumRef) {
                    sb.AppendFormat("{0}{1} = {2},{3}",
                        indent, itemDef.Name,
                        itemDef.RefEnumItemDef.Name, this.newLineStr);
                } else if (itemDef.Type == EnumItemType.OtherEnumRef) {
                    sb.AppendFormat("{0}{1} = {2},{3}",
                        indent, itemDef.Name,
                        GetEnumItemFullQualifiedName(itemDef.RefEnumItemDef),
                        this.newLineStr);
                }
            }

            sb.Append(end);

            output = sb.ToString();
        }

        private void GetStructDecl(
            ProtocolDescriptor.StructDef structDef,
            string indent, out string output)
        {
            StringBuilder sb = new StringBuilder();

            string start = string.Format(
                "{0}public sealed class {1} : BaseStruct{2}" +
                "{0}{{{2}",
                indent, structDef.Name, this.newLineStr);
            string end = string.Format(
                "{0}}}{1}",
                indent, this.newLineStr);
            string fieldDecl;
            string createFuncDecl;
            string constructorDecl;
            string copyConstructorDecl;
            string cloneFuncDecl;
            string encodeToStreamFuncDecl;
            string decodeFromStreamFuncDecl;
            string optionalFuncDecl;

            indent += "    ";
            GetStructDeclFieldDecl(
                structDef, indent, out fieldDecl);
            GetStructDeclCreateFunc(
                structDef, indent, out createFuncDecl);
            GetStructDeclConstructor(
                structDef, indent, out constructorDecl);
            GetStructDeclCopyConstructor(
                structDef, indent, out copyConstructorDecl);
            GetStructDeclCloneFunc(
                structDef, indent, out cloneFuncDecl);
            GetStructDeclEncodeToStreamFunc(
                structDef, indent, out encodeToStreamFuncDecl);
            GetStructDeclDecodeFromStreamFunc(
                structDef, indent, out decodeFromStreamFuncDecl);
            GetStructDeclOptionalFunc(
                structDef, indent, out optionalFuncDecl);

            sb.Append(start);
            sb.Append(fieldDecl);
            if (fieldDecl != "") {
                sb.Append(this.newLineStr);
            }
            sb.Append(createFuncDecl);
            sb.Append(this.newLineStr);
            sb.Append(constructorDecl);
            sb.Append(this.newLineStr);
            sb.Append(copyConstructorDecl);
            sb.Append(this.newLineStr);
            sb.Append(cloneFuncDecl);
            sb.Append(this.newLineStr);
            sb.Append(encodeToStreamFuncDecl);
            sb.Append(this.newLineStr);
            sb.Append(decodeFromStreamFuncDecl);
            if (optionalFuncDecl != "") {
                sb.Append(this.newLineStr);
                sb.Append(optionalFuncDecl);
            }
            sb.Append(end);

            output = sb.ToString();
        }

        private void GetStructDeclFieldDecl(
            ProtocolDescriptor.StructDef structDef,
            string indent, out string output)
        {
            StringBuilder sb = new StringBuilder();

            if (structDef.OptionalByteCount > 0) {
                sb.AppendFormat(
                    "{0}private byte[] _has_bits_ = new byte[{1}];{2}",
                    indent, structDef.OptionalByteCount, this.newLineStr);
            }

            for (int i = 0; i < structDef.Fields.Count; ++i) {
                ProtocolDescriptor.StructDef.FieldDef fieldDef =
                    structDef.Fields[i];

                string csharpType = GetCSharpType(fieldDef);
                string defaultValue = GetCSharpTypeDefaultValue(fieldDef);
                sb.AppendFormat("{0}public {1} {2} = {3};{4}",
                    indent, csharpType, fieldDef.Name, defaultValue,
                    this.newLineStr);
            }

            output = sb.ToString();
        }

        private void GetStructDeclCreateFunc(
            ProtocolDescriptor.StructDef structDef,
            string indent, out string output)
        {
            output = string.Format(
                "{0}public static {1} Create(){2}" +
                "{0}{{{2}" +
                "{0}    return new {1}();{2}" +
                "{0}}}{2}",
                indent, structDef.Name, this.newLineStr);
        }

        private void GetStructDeclConstructor(
            ProtocolDescriptor.StructDef structDef,
            string indent, out string output)
        {
            output = string.Format(
                "{0}public {1}(){2}" +
                "{0}{{{2}" +
                "{0}}}{2}",
                indent, structDef.Name, this.newLineStr);
        }

        private void GetStructDeclCopyConstructor(
            ProtocolDescriptor.StructDef structDef,
            string indent, out string output)
        {
            StringBuilder sb = new StringBuilder();

            string start = string.Format(
                "{0}public {1}({1} other){2}" +
                "{0}{{{2}",
                indent, structDef.Name, this.newLineStr);
            string end = string.Format(
                "{0}}}{1}",
                indent, this.newLineStr);

            sb.Append(start);

            indent += "    ";

            if (structDef.OptionalByteCount > 0) {
                sb.AppendFormat(
                    "{0}this._has_bits_ = " +
                    "other._has_bits_.Clone() as byte[];{1}",
                    indent, this.newLineStr);
            }

            for (int i = 0; i < structDef.Fields.Count; ++i) {
                ProtocolDescriptor.StructDef.FieldDef fieldDef =
                    structDef.Fields[i];
                FieldType checkType = fieldDef.Type;

                if (checkType == FieldType.I8 ||
                    checkType == FieldType.U8 ||
                    checkType == FieldType.I16 ||
                    checkType == FieldType.U16 ||
                    checkType == FieldType.I32 ||
                    checkType == FieldType.U32 ||
                    checkType == FieldType.I64 ||
                    checkType == FieldType.U64 ||
                    checkType == FieldType.String ||
                    checkType == FieldType.Bool ||
                    checkType == FieldType.Enum) {
                    sb.AppendFormat(
                        "{0}this.{1} = other.{1};{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else if (checkType == FieldType.Bytes) {
                    sb.AppendFormat(
                        "{0}this.{1} = other.{1}.Clone() as byte[];{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else if (checkType == FieldType.Struct) {
                    sb.AppendFormat(
                        "{0}this.{1} = new {2}(other.{1});{3}",
                        indent, fieldDef.Name,
                        GetStructFullQualifiedName(fieldDef.RefStructDef),
                        this.newLineStr);
                } else if (checkType == FieldType.List) {
                    if (fieldDef.ListType == FieldType.I8 ||
                        fieldDef.ListType == FieldType.U8 ||
                        fieldDef.ListType == FieldType.I16 ||
                        fieldDef.ListType == FieldType.U16 ||
                        fieldDef.ListType == FieldType.I32 ||
                        fieldDef.ListType == FieldType.U32 ||
                        fieldDef.ListType == FieldType.I64 ||
                        fieldDef.ListType == FieldType.U64 ||
                        fieldDef.ListType == FieldType.String ||
                        fieldDef.ListType == FieldType.Bool ||
                        fieldDef.ListType == FieldType.Enum) {
                        sb.AppendFormat(
                            "{0}this.{1} = new {2}(other.{1});{3}",
                            indent, fieldDef.Name,
                            GetCSharpType(fieldDef), this.newLineStr);
                    } else if (fieldDef.ListType == FieldType.Bytes) {
                        sb.AppendFormat(
                            "{0}this.{1} = other.{1}.ConvertAll(" +
                            "o => o.Clone() as byte[]);{2}",
                            indent, fieldDef.Name, this.newLineStr);
                    } else if (fieldDef.ListType == FieldType.Struct) {
                        sb.AppendFormat(
                            "{0}this.{1} = other.{1}.ConvertAll(" +
                            "o => new {2}(o));{3}",
                            indent, fieldDef.Name,
                            GetStructFullQualifiedName(fieldDef.RefStructDef),
                            this.newLineStr);
                    }
                }
            }

            sb.Append(end);

            output = sb.ToString();
        }

        private void GetStructDeclCloneFunc(
            ProtocolDescriptor.StructDef structDef,
            string indent, out string output)
        {
            output = string.Format(
                "{0}new public {1} Clone(){2}" +
                "{0}{{{2}" +
                "{0}    return ({1})CloneInternal();{2}" +
                "{0}}}{2}" +
                "{2}" +
                "{0}protected override BaseStruct CloneInternal(){2}" +
                "{0}{{{2}" +
                "{0}    return new {1}(this);{2}" +
                "{0}}}{2}",
                indent, structDef.Name, this.newLineStr);
        }

        private void GetStructDeclEncodeToStreamFunc(
            ProtocolDescriptor.StructDef structDef,
            string indent, out string output)
        {
            StringBuilder sb = new StringBuilder();

            string start = string.Format(
                "{0}public override void EncodeToStream(CodecOutputStream s){1}" +
                "{0}{{{1}",
                indent, this.newLineStr);
            string end = string.Format(
                "{0}}}{1}",
                indent, this.newLineStr);

            sb.Append(start);

            indent += "    ";

            if (structDef.OptionalByteCount > 0) {
                sb.AppendFormat(
                    "{0}for (int i = 0; i < {1}; ++i) {{{2}" +
                    "{0}    s.WriteUInt8(this._has_bits_[i]);{2}" +
                    "{0}}}{2}" +
                    "{2}",
                    indent, structDef.OptionalByteCount, this.newLineStr);
            }

            for (int i = 0; i < structDef.Fields.Count; ++i) {
                string writeStatement;
                GetStructDeclEncodeToStreamFuncWriteStatement(
                    structDef.Fields[i], indent, out writeStatement);
                sb.Append(writeStatement);
            }

            sb.Append(end);

            output = sb.ToString();
        }

        private void GetStructDeclEncodeToStreamFuncWriteStatement(
            ProtocolDescriptor.StructDef.FieldDef fieldDef,
            string indent, out string output)
        {
            StringBuilder sb = new StringBuilder();

            string optionalCheckStart = "";
            string optionalCheckEnd = "";

            if (fieldDef.IsOptional) {
                optionalCheckStart = string.Format(
                    "{0}if (has_{1}()) {{{2}",
                    indent, fieldDef.Name, this.newLineStr);
                optionalCheckEnd = string.Format(
                    "{0}}}{1}",
                    indent, this.newLineStr);
                indent += "    ";
            }

            sb.Append(optionalCheckStart);

            FieldType checkType;
            if (fieldDef.Type == FieldType.List) {
                checkType = fieldDef.ListType;
            } else {
                checkType = fieldDef.Type;
            }
            bool isList = (fieldDef.Type == FieldType.List);

            if (checkType == FieldType.I8) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}s.WriteLength(this.{1}.Count);{2}" +
                        "{0}for (int i = 0; i < this.{1}.Count; ++i) {{{2}" +
                        "{0}    s.WriteInt8(this.{1}[i]);{2}" +
                        "{0}}}{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}s.WriteInt8(this.{1});{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.U8) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}s.WriteLength(this.{1}.Count);{2}" +
                        "{0}for (int i = 0; i < this.{1}.Count; ++i) {{{2}" +
                        "{0}    s.WriteUInt8(this.{1}[i]);{2}" +
                        "{0}}}{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}s.WriteUInt8(this.{1});{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.I16) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}s.WriteLength(this.{1}.Count);{2}" +
                        "{0}for (int i = 0; i < this.{1}.Count; ++i) {{{2}" +
                        "{0}    s.WriteInt16(this.{1}[i]);{2}" +
                        "{0}}}{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}s.WriteInt16(this.{1});{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.U16) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}s.WriteLength(this.{1}.Count);{2}" +
                        "{0}for (int i = 0; i < this.{1}.Count; ++i) {{{2}" +
                        "{0}    s.WriteUInt16(this.{1}[i]);{2}" +
                        "{0}}}{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}s.WriteUInt16(this.{1});{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.I32) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}s.WriteLength(this.{1}.Count);{2}" +
                        "{0}for (int i = 0; i < this.{1}.Count; ++i) {{{2}" +
                        "{0}    s.WriteInt32(this.{1}[i]);{2}" +
                        "{0}}}{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}s.WriteInt32(this.{1});{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.U32) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}s.WriteLength(this.{1}.Count);{2}" +
                        "{0}for (int i = 0; i < this.{1}.Count; ++i) {{{2}" +
                        "{0}    s.WriteUInt32(this.{1}[i]);{2}" +
                        "{0}}}{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}s.WriteUInt32(this.{1});{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.I64) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}s.WriteLength(this.{1}.Count);{2}" +
                        "{0}for (int i = 0; i < this.{1}.Count; ++i) {{{2}" +
                        "{0}    s.WriteInt64(this.{1}[i]);{2}" +
                        "{0}}}{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}s.WriteInt64(this.{1});{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.U64) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}s.WriteLength(this.{1}.Count);{2}" +
                        "{0}for (int i = 0; i < this.{1}.Count; ++i) {{{2}" +
                        "{0}    s.WriteUInt64(this.{1}[i]);{2}" +
                        "{0}}}{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}s.WriteUInt64(this.{1});{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.String) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}s.WriteLength(this.{1}.Count);{2}" +
                        "{0}for (int i = 0; i < this.{1}.Count; ++i) {{{2}" +
                        "{0}    s.WriteString(this.{1}[i]);{2}" +
                        "{0}}}{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}s.WriteString(this.{1});{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.Bytes) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}s.WriteLength(this.{1}.Count);{2}" +
                        "{0}for (int i = 0; i < this.{1}.Count; ++i) {{{2}" +
                        "{0}    s.WriteBytes(this.{1}[i]);{2}" +
                        "{0}}}{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}s.WriteBytes(this.{1});{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.Bool) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}s.WriteLength(this.{1}.Count);{2}" +
                        "{0}for (int i = 0; i < this.{1}.Count; ++i) {{{2}" +
                        "{0}    s.WriteBool(this.{1}[i]);{2}" +
                        "{0}}}{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}s.WriteBool(this.{1});{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.Enum) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}s.WriteLength(this.{1}.Count);{2}" +
                        "{0}for (int i = 0; i < this.{1}.Count; ++i) {{{2}" +
                        "{0}    s.WriteInt32((int)this.{1}[i]);{2}" +
                        "{0}}}{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}s.WriteInt32((int)this.{1});{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.Struct) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}s.WriteLength(this.{1}.Count);{2}" +
                        "{0}for (int i = 0; i < this.{1}.Count; ++i) {{{2}" +
                        "{0}    this.{1}[i].EncodeToStream(s);{2}" +
                        "{0}}}{2}",
                        indent, fieldDef.Name, this.newLineStr);
                } else {
                    sb.AppendFormat(
                        "{0}this.{1}.EncodeToStream(s);{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            }

            sb.Append(optionalCheckEnd);

            output = sb.ToString();
        }

        private void GetStructDeclDecodeFromStreamFunc(
            ProtocolDescriptor.StructDef structDef,
            string indent, out string output)
        {
            StringBuilder sb = new StringBuilder();

            string start = string.Format(
                "{0}public override void DecodeFromStream(CodecInputStream s){1}" +
                "{0}{{{1}",
                indent, this.newLineStr);
            string end = string.Format(
                "{0}}}{1}",
                indent, this.newLineStr);

            sb.Append(start);

            indent += "    ";

            if (structDef.OptionalByteCount > 0) {
                sb.AppendFormat(
                    "{0}for (int i = 0; i < {1}; ++i) {{{2}" +
                    "{0}    this._has_bits_[i] = s.ReadUInt8();{2}" +
                    "{0}}}{2}" +
                    "{2}",
                    indent, structDef.OptionalByteCount, this.newLineStr);
            }

            for (int i = 0; i < structDef.Fields.Count; ++i) {
                string readStatement;
                GetStructDeclDecodeFromStreamFuncReadStatement(
                    structDef.Fields[i], indent, out readStatement);
                sb.Append(readStatement);
            }

            sb.Append(end);

            output = sb.ToString();
        }

        private void GetStructDeclDecodeFromStreamFuncReadStatement(
            ProtocolDescriptor.StructDef.FieldDef fieldDef,
            string indent, out string output)
        {
            StringBuilder sb = new StringBuilder();

            string start = "";
            string end = "";

            if (fieldDef.IsOptional) {
                start = string.Format(
                    "{0}if (has_{1}()) {{{2}",
                    indent, fieldDef.Name, this.newLineStr);
                end = string.Format(
                    "{0}}}{1}",
                    indent, this.newLineStr);
                indent += "    ";
            }

            FieldType checkType;
            if (fieldDef.Type == FieldType.List) {
                checkType = fieldDef.ListType;
            } else {
                checkType = fieldDef.Type;
            }
            bool isList = (fieldDef.Type == FieldType.List);

            if (isList && fieldDef.IsOptional == false) {
                start += string.Format("{0}{{{1}",
                    indent, this.newLineStr);
                end = string.Format("{0}}}{1}",
                    indent, this.newLineStr) + end;
                indent += "    ";
            }

            sb.Append(start);

            if (checkType == FieldType.I8) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}int length = s.ReadLength();{1}" +
                        "{0}this.{2}.Clear();{1}" +
                        "{0}for (int i = 0; i < length; ++i) {{{1}" +
                        "{0}    this.{2}.Add(s.ReadInt8());{1}" +
                        "{0}}}{1}",
                        indent, this.newLineStr, fieldDef.Name);
                } else {
                    sb.AppendFormat(
                        "{0}this.{1} = s.ReadInt8();{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.U8) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}int length = s.ReadLength();{1}" +
                        "{0}this.{2}.Clear();{1}" +
                        "{0}for (int i = 0; i < length; ++i) {{{1}" +
                        "{0}    this.{2}.Add(s.ReadUInt8());{1}" +
                        "{0}}}{1}",
                        indent, this.newLineStr, fieldDef.Name);
                } else {
                    sb.AppendFormat(
                        "{0}this.{1} = s.ReadUInt8();{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.I16) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}int length = s.ReadLength();{1}" +
                        "{0}this.{2}.Clear();{1}" +
                        "{0}for (int i = 0; i < length; ++i) {{{1}" +
                        "{0}    this.{2}.Add(s.ReadInt16());{1}" +
                        "{0}}}{1}",
                        indent, this.newLineStr, fieldDef.Name);
                } else {
                    sb.AppendFormat(
                        "{0}this.{1} = s.ReadInt16();{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.U16) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}int length = s.ReadLength();{1}" +
                        "{0}this.{2}.Clear();{1}" +
                        "{0}for (int i = 0; i < length; ++i) {{{1}" +
                        "{0}    this.{2}.Add(s.ReadUInt16());{1}" +
                        "{0}}}{1}",
                        indent, this.newLineStr, fieldDef.Name);
                } else {
                    sb.AppendFormat(
                        "{0}this.{1} = s.ReadUInt16();{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.I32) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}int length = s.ReadLength();{1}" +
                        "{0}this.{2}.Clear();{1}" +
                        "{0}for (int i = 0; i < length; ++i) {{{1}" +
                        "{0}    this.{2}.Add(s.ReadInt32());{1}" +
                        "{0}}}{1}",
                        indent, this.newLineStr, fieldDef.Name);
                } else {
                    sb.AppendFormat(
                        "{0}this.{1} = s.ReadInt32();{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.U32) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}int length = s.ReadLength();{1}" +
                        "{0}this.{2}.Clear();{1}" +
                        "{0}for (int i = 0; i < length; ++i) {{{1}" +
                        "{0}    this.{2}.Add(s.ReadUInt32());{1}" +
                        "{0}}}{1}",
                        indent, this.newLineStr, fieldDef.Name);
                } else {
                    sb.AppendFormat(
                        "{0}this.{1} = s.ReadUInt32();{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.I64) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}int length = s.ReadLength();{1}" +
                        "{0}this.{2}.Clear();{1}" +
                        "{0}for (int i = 0; i < length; ++i) {{{1}" +
                        "{0}    this.{2}.Add(s.ReadInt64());{1}" +
                        "{0}}}{1}",
                        indent, this.newLineStr, fieldDef.Name);
                } else {
                    sb.AppendFormat(
                        "{0}this.{1} = s.ReadInt64();{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.U64) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}int length = s.ReadLength();{1}" +
                        "{0}this.{2}.Clear();{1}" +
                        "{0}for (int i = 0; i < length; ++i) {{{1}" +
                        "{0}    this.{2}.Add(s.ReadUInt64());{1}" +
                        "{0}}}{1}",
                        indent, this.newLineStr, fieldDef.Name);
                } else {
                    sb.AppendFormat(
                        "{0}this.{1} = s.ReadUInt64();{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.String) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}int length = s.ReadLength();{1}" +
                        "{0}this.{2}.Clear();{1}" +
                        "{0}for (int i = 0; i < length; ++i) {{{1}" +
                        "{0}    this.{2}.Add(s.ReadString());{1}" +
                        "{0}}}{1}",
                        indent, this.newLineStr, fieldDef.Name);
                } else {
                    sb.AppendFormat(
                        "{0}this.{1} = s.ReadString();{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.Bytes) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}int length = s.ReadLength();{1}" +
                        "{0}this.{2}.Clear();{1}" +
                        "{0}for (int i = 0; i < length; ++i) {{{1}" +
                        "{0}    this.{2}.Add(s.ReadBytes());{1}" +
                        "{0}}}{1}",
                        indent, this.newLineStr, fieldDef.Name);
                } else {
                    sb.AppendFormat(
                        "{0}this.{1} = s.ReadBytes();{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.Bool) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}int length = s.ReadLength();{1}" +
                        "{0}this.{2}.Clear();{1}" +
                        "{0}for (int i = 0; i < length; ++i) {{{1}" +
                        "{0}    this.{2}.Add(s.ReadBool());{1}" +
                        "{0}}}{1}",
                        indent, this.newLineStr, fieldDef.Name);
                } else {
                    sb.AppendFormat(
                        "{0}this.{1} = s.ReadBool();{2}",
                        indent, fieldDef.Name, this.newLineStr);
                }
            } else if (checkType == FieldType.Enum) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}int length = s.ReadLength();{1}" +
                        "{0}this.{2}.Clear();{1}" +
                        "{0}for (int i = 0; i < length; ++i) {{{1}" +
                        "{0}    this.{2}.Add(({3})s.ReadInt32());{1}" +
                        "{0}}}{1}",
                        indent, this.newLineStr, fieldDef.Name,
                        GetEnumFullQualifiedName(fieldDef.RefEnumDef));
                } else {
                    sb.AppendFormat(
                        "{0}this.{1} = ({2})s.ReadInt32();{3}",
                        indent, fieldDef.Name,
                        GetEnumFullQualifiedName(fieldDef.RefEnumDef),
                        this.newLineStr);
                }
            } else if (checkType == FieldType.Struct) {
                if (isList) {
                    sb.AppendFormat(
                        "{0}int length = s.ReadLength();{1}" +
                        "{0}this.{2}.Clear();{1}" +
                        "{0}for (int i = 0; i < length; ++i) {{{1}" +
                        "{0}    this.{2}.Add(s.ReadStruct<{3}>());{1}" +
                        "{0}}}{1}",
                        indent, this.newLineStr, fieldDef.Name,
                        GetStructFullQualifiedName(fieldDef.RefStructDef));
                } else {
                    sb.AppendFormat(
                        "{0}this.{1} = s.ReadStruct<{2}>();{3}",
                        indent, fieldDef.Name,
                        GetStructFullQualifiedName(fieldDef.RefStructDef),
                        this.newLineStr);
                }
            }

            sb.Append(end);

            output = sb.ToString();
        }

        private void GetStructDeclOptionalFunc(
            ProtocolDescriptor.StructDef structDef,
            string indent, out string output)
        {
            List<string> decls = new List<string>();

            for (int i = 0; i < structDef.Fields.Count; ++i) {
                ProtocolDescriptor.StructDef.FieldDef fieldDef =
                    structDef.Fields[i];

                if (fieldDef.IsOptional == false) {
                    continue;
                }

                string mask = string.Format("0x{0:x2}",
                    1 << fieldDef.OptionalFieldIndex % 8);
                string csharpType = GetCSharpType(fieldDef);

                decls.Add(string.Format(
                    "{0}public bool has_{1}(){2}" +
                    "{0}{{{2}" +
                    "{0}    return (this._has_bits_[{3}] & {4}) > 0;{2}" +
                    "{0}}}{2}" +
                    "{2}" +
                    "{0}public void set_has_{1}(){2}" +
                    "{0}{{{2}" +
                    "{0}    this._has_bits_[{3}] |= {4};{2}" +
                    "{0}}}{2}" +
                    "{2}" +
                    "{0}public void clear_has_{1}(){2}" +
                    "{0}{{{2}" +
                    "{0}    this._has_bits_[{3}] &= (~{4} & 0xff);{2}" +
                    "{0}}}{2}" +
                    "{2}" +
                    "{0}public void set_{1}({5} val){2}" +
                    "{0}{{{2}" +
                    "{0}    set_has_{1}();{2}" +
                    "{0}    this.{1} = val;{2}" +
                    "{0}}}{2}",
                    indent, fieldDef.Name, this.newLineStr,
                    fieldDef.OptionalFieldIndex / 8, mask, csharpType));
            }

            output = string.Join(this.newLineStr, decls);
        }

        private void GetEnumMapDecl(
            ProtocolDescriptor.EnumMapDef enumMapDef,
            string indent, out string output)
        {
            StringBuilder sbEnumConst = new StringBuilder();
            StringBuilder sbIdList = new StringBuilder();
            StringBuilder sbFuncList = new StringBuilder();
            StringBuilder sbIdInit = new StringBuilder();

            for (int i = 0; i < enumMapDef.Items.Count; ++i) {
                ProtocolDescriptor.EnumMapDef.ItemDef itemDef =
                    enumMapDef.Items[i];

                sbEnumConst.AppendFormat(
                    "{0}    public const int {1} = ",
                    indent, itemDef.Name);

                if (itemDef.Type == EnumMapItemType.Default ||
                    itemDef.Type == EnumMapItemType.Int) {
                    sbEnumConst.AppendFormat("{0};{1}",
                        itemDef.IntValue, this.newLineStr);
                } else if (itemDef.Type == EnumMapItemType.CurrentEnumRef) {
                    sbEnumConst.AppendFormat("{0};{1}",
                        itemDef.RefEnumItemDef.Name, this.newLineStr);
                }

                if (itemDef.RefStructDef == null) {
                    continue;
                }

                sbIdList.AppendFormat("{0}        {1},{2}",
                    indent, itemDef.Name, this.newLineStr);
                sbFuncList.AppendFormat("{0}        {1}.Create,{2}",
                    indent, GetStructFullQualifiedName(itemDef.RefStructDef),
                    this.newLineStr);
                sbIdInit.AppendFormat(
                    "{0}        Id<{1}>.Value = {2};{3}",
                    indent, GetStructFullQualifiedName(itemDef.RefStructDef),
                    itemDef.Name, this.newLineStr);
            }

            if (sbEnumConst.Length > 0) {
                sbEnumConst.AppendFormat(this.newLineStr);
            }

            output = string.Format(
                "{0}public sealed class {1}{2}" +
                "{0}{{{2}" +
                "{3}" +
                "{0}    private static int[] s_id_list_ = {{{2}" +
                "{4}" +
                "{0}    }};{2}" +
                "{2}" +
                "{0}    private static BaseStruct.CreateFunc[] " +
                "s_create_func_list_ = {{{2}" +
                "{5}" +
                "{0}    }};{2}" +
                "{2}" +
                "{0}    private class Id<T> where T : BaseStruct{2}" +
                "{0}    {{{2}" +
                "{0}        public static int Value;{2}" +
                "{0}    }}{2}" +
                "{2}" +
                "{0}    static {1}(){2}" +
                "{0}    {{{2}" +
                "{6}" +
                "{0}    }}{2}" +
                "{2}" +
                "{0}    public static int GetId<T>() where T : BaseStruct{2}" +
                "{0}    {{{2}" +
                "{0}        return Id<T>.Value;{2}" +
                "{0}    }}{2}" +
                "{2}" +
                "{0}    public static BaseStruct Create(int id){2}" +
                "{0}    {{{2}" +
                "{0}        int index = Array.BinarySearch(s_id_list_, id);{2}" +
                "{0}        if (index < 0) {{{2}" +
                "{0}            return null;{2}" +
                "{0}        }} else {{{2}" +
                "{0}            return s_create_func_list_[index]();{2}" +
                "{0}        }}{2}" +
                "{0}    }}{2}" +
                "{0}}}{2}",
                indent, enumMapDef.Name, this.newLineStr,
                sbEnumConst.ToString(), sbIdList.ToString(),
                sbFuncList.ToString(), sbIdInit.ToString());
        }
    }
}
